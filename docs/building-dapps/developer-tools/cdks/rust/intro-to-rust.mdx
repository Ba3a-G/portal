---
keywords: [beginner, rust, tutorial, deploying canisters, deploying]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";
import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

# Introduction to Rust canister development

<MarkdownChipRow labels={["Beginner", "Rust", "Tutorial"]} />

Rust is a powerful and type-sound modern programming language with an active developer community. Because Rust compiles to WebAssembly, it offers a rich development environment for writing dapps to run on ICP.

Developing smart contracts in Rust is supported on ICP through the Rust canister development kit (CDK), which is developed and maintained by DFINITY. Rust is natively supported by ICP developer tools such as [`dfx`](/docs/current/building-dapps/developer-tools/dfx/) and [PocketIC](/docs/current/building-dapps/creating-dapps/test/pocket-ic), and can be used with features such as [HTTP certification](/docs/current/building-dapps/using-network-features/using-http/http-certification/custom-http-canisters), [composite queries](/docs/current/building-dapps/calling-dapps/query-calls), and [query stats](/docs/current/building-dapps/calling-dapps/query-calls).

This guide provides an introduction to using Rust for developing backend canisters and covers the basic infrastructure of Rust canisters as well as design considerations and observability.

To support Rust development, the IC SDK includes the [Rust canister development kit (Rust CDK)](https://github.com/dfinity/cdk-rs).

While using the IC SDK is the typical path for most developers, experienced Rust developers may choose to circumvent the IC SDK entirely and use the Rust CDK directly. This documentation assumes the reader is using the IC SDK to build Rust canisters.

The Rust CDK consists of the following crates:

- [`ic-cdk`](https://crates.io/crates/ic-cdk): Core methods that enable Rust programs to interact with the ICP system API.

- [`ic-cdk-macros`](https://crates.io/crates/ic-cdk-macros): Defines the procedural macros (e.g., `update`, `query`, `import`) that facilitate building operation endpoints and APIs.

- [`ic-cdk-timers`](https://crates.io/crates/ic-cdk-timers): Provides an API to schedule multiple timers and periodic tasks.

## Creating a new project

<Tabs>
<TabItem value="prereq" label="Prerequisites" default>

<input type="checkbox"/> <a href="/docs/current/building-dapps/getting-started/install">Install the IC SDK.</a> Note: While using the IC SDK is the typical path for most developers, experienced Rust developers may choose to circumvent IC SDK entirely and use the <a href="https://github.com/dfinity/cdk-rs"> Rust CDK </a> directly.
<div>
</div>
<input type="checkbox"/> <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">Download and install Rust.</a>
<div>
</div>
<input type="checkbox"/> Download and install the <code>wasm32-unknown-unknown</code> target: <code>rustup target add wasm32-unknown-unknown</code>
</TabItem>
</Tabs>

Open a terminal window on your local computer, if you don’t already have one open.

Use `dfx new <project_name> --type=rust` to create a new project:

```bash
dfx start --clean --background
dfx new hello_world --type=rust
```

Then, navigate into your project directory by running the command:

``` bash
cd hello_world
```

Open the `src/hello_world_backend/src/lib.rs` file in a text editor. It should contain the following code:

```rust file=../../../../references/samples/rust/hello/src/hello/lib.rs
```

## Deploying the canister locally

### Create

First, create an empty canister for the canister code to be installed into. To create the canister, run the command:

```bash
dfx start --clean --background
dfx canister create hello_world_backend
```

The output will resemble the following:

```bash
Creating canister hello_world_backend...
hello_world_backend canister created with canister id: br5f7-7uaaa-aaaaa-qaaca-cai
```

### Compile

Next, you need to compile your program into a WebAssembly module that can be deployed on ICP by building the canister. To compile the canister's code, run the command:

```bash
dfx build hello_world_backend
```

### Install

Then, install the compiled Wasm module into your canister with the command:

```bash
dfx canister install hello_world_backend
```

### Deploy

To deploy the canister, use the command:

```bash
dfx deploy hello_world_backend
```

This command deploys just the `hello_world_backend` canister. To deploy all canisters in the `dfx.json` file, use the command:

```bash
dfx deploy
```

## Deploying the canister to the mainnet

To deploy to the mainnet, you will need a balance of cycles.

[Learn more about how to get cycles](/docs/current/building-dapps/getting-started/deploy-and-manage).

Once you have gotten cycles, check the status of the mainnet to confirm that your local environment can connect to it. You can ping the mainnet with the command:

```bash
dfx ping ic
```

The output should resemble the following:

```bash
{
  "ic_api_version": "0.18.0"  "impl_hash": "d639545e0f38e075ad240fd4ec45d4eeeb11e1f67a52cdd449cd664d825e7fec"  "impl_version": "8dc1a28b4fb9605558c03121811c9af9701a6142"  "replica_health_status": "healthy"  "root_key": [48, 129, 130, 48, 29, 6, 13, 43, 6, 1, 4, 1, 130, 220, 124, 5, 3, 1, 2, 1, 6, 12, 43, 6, 1, 4, 1, 130, 220, 124, 5, 3, 2, 1, 3, 97, 0, 129, 76, 14, 110, 199, 31, 171, 88, 59, 8, 189, 129, 55, 60, 37, 92, 60, 55, 27, 46, 132, 134, 60, 152, 164, 241, 224, 139, 116, 35, 93, 20, 251, 93, 156, 12, 213, 70, 217, 104, 95, 145, 58, 12, 11, 44, 197, 52, 21, 131, 191, 75, 67, 146, 228, 103, 219, 150, 214, 91, 155, 180, 203, 113, 113, 18, 248, 71, 46, 13, 90, 77, 20, 80, 95, 253, 116, 132, 176, 18, 145, 9, 28, 95, 135, 185, 136, 131, 70, 63, 152, 9, 26, 11, 170, 174]
}
```

Then, to deploy the canister to the mainnet, use the command:

```bash
dfx deploy hello_world_backend --network ic
```

:::info
For all commands that are intended to interact with the mainnet, the `--network ic` flag needs to be used.
:::

## Interacting with the canister

To test the canister's functionality, call one of the canister's methods directly from the command line. In this example, this canister only has one method, `greet`, so that will be the one tested.

To test this method, make a call to the `greet` method with the command:

```bash
dfx canister call hello_world_backend greet everyone
```

The output will resemble:

```bash
("Hello, everyone!")
```

You can replace the last input string with any name you'd like, such as:

```bash
dfx canister call hello_world_backend greet Bob
```

This will return the output:

```bash
("Hello, Bob!")
```

In addition to testing the canister's functionality, the canister can be interacted with using other `dfx` commands. For example:

To deposit cycles from the wallet into the canister, use the command:

```
dfx canister deposit-cycles [cycles amount] [canister-name]
```

To get the identifier of a canister, use the command:

```
dfx canister id [canister-name]
```

To get a canister's Wasm module hash and its current controllers, use the command:

```
dfx canister info [canister-name]
```

## Testing the canister with PocketIC

[PocketIC](/docs/current/building-dapps/creating-dapps/test/pocket-ic) is a lightweight, deterministic testing solution for programmatic testing of canisters that seamlessly integrates with existing testing infrastructure, such as `cargo test`.

[Learn more about PocketIC](/docs/current/building-dapps/creating-dapps/test/pocket-ic).

For Rust canisters, PocketIC can be imported into your project with the code:

```rust
use pocket_ic::PocketIc;
```

Then, in your code, you can create a new PocketIC instance with the code:

```rust
let pic = PocketIc::new();
```

The following is a complete example for testing a counter canister:

```rust
use candid::encode_one;
use pocket_ic::PocketIc;

 #[test]
 fn test_counter_canister() {
    let pic = PocketIc::new();
    // Create an empty canister as the anonymous principal and add cycles.
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);

    let wasm_bytes = load_counter_wasm(...);
    pic.install_canister(canister_id, wasm_bytes, vec![], None);
    // 'inc' is a counter canister method.
    call_counter_canister(&pic, canister_id, "inc");
    // Check if it had the desired effect.
    let reply = call_counter_canister(&pic, canister_id, "read");
    assert_eq!(reply, WasmResult::Reply(vec![0, 0, 0, 1]));
 }

fn call_counter_canister(pic: &PocketIc, canister_id: CanisterId, method: &str) -> WasmResult {
    pic.update_call(canister_id, Principal::anonymous(), method, encode_one(()).unwrap())
        .expect("Failed to call counter canister")
}
```

[View additional PocketIC testing examples](/docs/current/building-dapps/creating-dapps/test/pocket-ic).
