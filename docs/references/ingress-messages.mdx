---
keywords: [intermediate, reference, security, ingress message, query call, update call, error handling, idempotency]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Ingress messages on ICP

<MarkdownChipRow labels={["Intermediate","Reference", "Security"]} />

## Overview

Ingress messages are calls to ICP canisters that are sent by external entities, such as users, usually through an agent like [agent-js](https://github.com/dfinity/agent-js/tree/main) that runs within a web application, or [agent-rs](https://github.com/dfinity/agent-rs/tree/main) in a Rust application. See also the introductory [call overview](/docs/current/developer-docs/smart-contracts/call/overview). 

For example, you can browse what ingress messages can be sent to the ckBTC ledger by browsing through its [API on the dashboard](https://dashboard.internetcomputer.org/canister/mxzaz-hqaaa-aaaar-qaada-cai). The tool also allows to send messages, using agent-js behind the scenes.

In the following, we discuss ICP's ingress message APIs. While these APIs are defined in detail in the [HTTPS interface specification](/docs/current/references/ic-interface-spec#http-interface), we provide a more high level and intuitive overview of ingress messaging. In addition to discussing the happy path of ingress messaging, we lay a special focus on error handling. That aspect is particularly important as it can be tricky to determine if an ingress message has actually been successfully executed. In the worst case, misinterpreting errors could lead to bugs such as double spending.

## Types of ingress messages

ICP supports several types of calls, as defined in the [HTTPS interface specification](/docs/current/references/ic-interface-spec#http-interface). These include query and update calls. 

## Query Calls
Queries don't modify a canister's state and are answered and signed by a single replica. Responses are obtained within milliseconds, but they are typically not signed by the subnet, which implies that a malicious replica or boundary node could arbitrarily modify the response. 

Some applications may have higher authenticity requirements for query responses. For example, if a dapp queries a proposal description that the user then votes on, it may not be acceptable that a single replica or boundary node can tamper with that information. one can consider issuing query calls as update calls instead, see the next section. While that's easy to implement, it makes the calls significantly slower. To avoid this negative performance impact, for some use cases one can sign the data beforehand and provide [certified variables](/docs/current/developer-docs/security/security-best-practices/data-integrity-and-authenticity#certified-variables) in query responses. However, this can be complex to implement, depending on the specific use case. An example where certified variables are used is the [HTTP asset certification](/docs/current/developer-docs/security/security-best-practices/data-integrity-and-authenticity#use-http-asset-certification-and-avoid-serving-your-dapp-through-rawicp0io). 

Error handling for queries is typically simple: on error, one can simply retry until a successful response is received. 

## Update Calls
Updates can modify a canister's state and thus go through consensus, typically taking 1-3 seconds. They return certified responses (signed by the subnet), providing authenticity within the subnet's corruption bounds.

Update calls can be made [synchronously](/docs/current/references/ic-interface-spec#http-sync-call-overview) or [asynchronously](/docs/current/references/ic-interface-spec#http-async-call-overview). 

A [synchronous `call`](https://internetcomputer.org/docs/current/references/ic-interface-spec#http-call) follows the "call and await" pattern. In the success case, it maintains the HTTPS connection until a certified response is produced, as illustrated below. 

![Dev containers 1](./_attachments/ingress_sync_call.png)

Compared to the [asynchronous `call`](/docs/current/references/ic-interface-spec#http-async-call) endpoint, where the [`read_state`](/docs/current/references/ic-interface-spec#http-read-state) endpoint is used to poll for the request status and obtain the reply, the synchronous endpoint removes the need to poll for the response in the success case. 

However, a response may not be produced within an implementation-specific timeout. In that case, the synchronous endpoint behaves like the asynchronous endpoint: it returns a `202` response, and the client needs to poll the [read_state](/docs/current/references/ic-interface-spec#http-read-state) endpoint to poll for the request status and obtain the reply, as illustrated below.

![Dev containers 1](./_attachments/ingress_async_call.png)

### Update call errors and their implications

A number of errors could occur in the above flow. The following are examples of errors, indicated using the numbers in the diagram:
1. Due to misconfiguration, the agent might fail to successfully sign the update call and not even send it off.
2. The call to the boundary node may fail, for example because the agent or the boundary node is offline and the call times out.
3. Calls (`call` or `read_state`) to the IC node may fail, for example due to 
   1. the node being offline
   2. an execution pre-processing error (status `200` in case of the async call)
   3. or the node being incapable of handling the request (status `5xx`)
4. It could be that the call is never accepted for processing. For example, a malicious boundary node could block the status response. Thus, the agent would never see a [status like `received`, `processing`, etc.](/docs/current/references/ic-interface-spec#state-tree-request-status) upon calling `read_state`.
5. The certificate in the `read_state` response could be invalid. For example, it could be malformed or have an invalid signature.
6. Finally, the call could be `rejected` (see [rejected status](/docs/current/references/ic-interface-spec#state-tree-request-status) and [reject codes](/docs/current/references/ic-interface-spec#reject-codes)).

When seeing errors 2-5, the call may still have been successfully executed. For example, a malicious boundary node or node could return an error, but still successfully execute the request. Only if a `rejected` response is received along with a valid certificate, ICP guarantees that the call hasn’t been executed and never will be.

Some operations, such as transfers, must not be executed multiple times. If a call was `rejected` as described above, it is safe to retry the operation. In all other error cases however, retrying can be risky because the call could still successfully execute, potentially leading to severe security vulnerabilities such as double spending.

In general there are cases where it is impossible to determine if a call was successful. For example, suppose
* The client loses its connection until the request status has been removed from the state tree. (Recall that ICP will remove the request from the system state tree some time after ingress expiry.)
* There is no application specific way to tell if the call successfully executed. For example, the canister does not provide a way to find out if the call happened.

In this situation, it is indistinguishable if the call was successful, but all information has already been removed from the system state tree, or the call never made it into the state tree in the first place and hasn't been executed. 

### Recommendations and best practices for secure update call handling

The best way to handle errors as discussed above is to implement safe retries using idempotent calls. This is discussed in the [best practices on safe retries and idempotency](/docs/current/developer-docs/smart-contracts/best-practices/idempotency).

It may not always be possible to make call endpoints idempotent. For example, an endpoint that is not under the developer’s control may simply not have this property. In this case, we still suggest retrying as a best effort. However, the guarantees in this case will be weaker compared to using idempotent calls.

ICP provides a built-in deduplication feature. Namely, if two calls with identical [request id](/docs/current/references/ic-interface-spec#request-ids) are made, the transaction is processed at most once. For two calls to have the same request id, they must have the same values for all fields `request_type`, `sender`, `ingress_expiry`, `nonce`, `canister_id`, `method_name`, and `arg`. This gives idempotency, but only until [ingress_expiry](/docs/current/references/ic-interface-spec#authentication) is reached, because after the message expires, ICP [may remove the request_id from the system state tree](/docs/current/references/ic-interface-spec#state-tree-request-status). Thus, such requests can be safely retried.

However, as ICP rejects `ingress_expiry` that is too far in the future, the time window for idempotency is limited. To maximize the window, one can maximize `ingress_expiry` in this case and set the timeout to `ingress_expiry` as well.

There are two options for retries:
* Only poll `read_state` until `ingress_expiry` is reached. Note that this may be hard if the IC time and local time differ.
* Poll `read_state` for e.g. `30s` and then retry the `call`, loop until `ingress_expiry` (e.g. `5min`). This can be beneficial because a call that didn’t make it would be retried.

If the timeout is reached, there is no way for the client to determine if the transaction was successful, unless the canister’s API provides this information. In this case, after the message has expired, the user must be instructed to manually check the status of the transaction, using application specific APIs. There can be (hopefully exotic) cases where checking is not possible, and the user simplay can’t tell if the transaction happened. Ideally, timeouts should be rare and not occur during normal operation.
